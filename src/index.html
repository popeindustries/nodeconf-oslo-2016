<!DOCTYPE html>
<html class="">
<head>
  <meta charset="utf-8">
  <title>NodeConf Oslo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
  <link rel="stylesheet" type="text/css" href="index.css">
  <link rel="stylesheet" type="text/css" href="src/lib/monokai.css">
  <link rel="stylesheet" type="text/css" href="src/lib/monokai-sublime.css">
</head>
<body>
  <div class="slides">
    <section id="title">
      <div class="top">
        <h1>Thunder</h1>
      </div>
      <div class="middle">
        <h1>&amp;</h1>
      </div>
      <div class="bottom">
        <h1>Lightning</h1>
      </div>
      <div class="notes">
      </div>
    </section>

    <section id="history">
      <img class="logo logo--yr" inline src="src/images/logo-yr--circle.svg">
      <div class="partner-logos">
        <img class="logo logo--nrk" inline src="src/images/logo-nrk.svg">
        <img class="logo logo--met" inline src="src/images/logo-met.svg">
      </div>
      <h3 class="max-users">9,000,000 users/week</h3>
      <img class="stats" inline src="src/images/stats.svg">
      <h3 class="launch-date">Sept 19, 2007</h3>
      <h3 class="mobile-users">60% mobile</h3>
      <div class="notes">
        <p class="note"></p>
        <p class="note step">Yr is a collaboration between Norway's state broadcaster, NRK, (where I work) and the state Meteorological Institute, Met</p>
        <p class="note">NRK and Met have collaborated to deliver weather reports to Norwegians since forever, first via radio, then TV</p>
        <p class="note">In 2006, Met decided to make it's data freely available to the public. North Americans have always enjoyed free access to weather data, but in Europe, that largely hasn't been the case, and certainly wasn't until Norway decided to shake things up. Shortly after that, NRK and Met released Yr</p>
        <p class="note step">The service quickly became one of the most used in Norway...</p>
        <p class="note step">...and last summer had 9 million (unique) visitors per week...</p>
        <p class="note step">...of which roughly 60% was mobile traffic (evenly split between web and native apps), on 11,996 different devices</p>
      </div>
    </section>

    <section id="geography">
      <img class="map" inline src="src/images/map.svg">
      <h2 class="title">web sessions (2015)</h2>
      <h3 class="no-users">578,850,000 from Norway (47%)</h3>
      <h3 class="nk-users">31 from North Korea</h3>
      <div class="notes">
        <p class="note">Now, there are only 5 million people living in Norway, so you might be wondring "where does all this traffic come from?"</p>
        <p class="note step">According to Google, the answer would be everywhere except, apparently, Western Sahara</p>
        <p class="note step">Norway accounts for a little under half of the traffic, with most of the remaining top 10 coming from northern Europe. </p>
        <p class="note">Strangely, Yr is big with South African farmers, and though it's <em>not</em> so big in Japan...</p>
        <p class="note step">...there were 31 sessions recorded from North Korea</p>
      </div>
    </section>

    <section id="mobile">
      <div class="phone n95">
        <figure class="front ">
          <img src="src/images/n95-old.png">
          <figcaption>2007</figcaption>
        </figure>
      </div>
      <div class="phone iphone">
        <figure class="front">
          <img src="src/images/iphone-old.png">
          <figcaption>2013</figcaption>
        </figure>
        <figure class="back">
          <img src="src/images/iphone-old-www.png">
          <figcaption>2013</figcaption>
        </figure>
      </div>
      <div class="m">
        <h3>m.yr.no</h3>
        <ul>
          <li class="good">light on bandwidth</li>
          <li class="good">flexible width</li>
          <li class="bad">light on features</li>
        </ul>
      </div>
      <div class="www">
        <h3>www.yr.no</h3>
        <ul>
          <li class="good">heavy on features</li>
          <li class="bad">heavy on bandwidth</li>
          <li class="bad">fixed width</li>
        </ul>
      </div>
      <div class="notes">
        <p class="note">Yr is a great success story, but the web has changed a lot over the last 10 years</p>
        <p class="note step">In 2007, if you fired-up your top-of-the-line Nokia N95, the website would have looked something like this</p>
        <p class="note step">Unfortunately, in 2013, it would still have looked something like this...</p>
        <p class="note step">...though with a little bit of work, you could opt for the desktop version instead</p>
        <p class="note step">The mobile version had a lot going for it: it was light on bandwidth, and it worked well on small screens, but it was also very light on features</p>
        <p class="note step">The desktop version, on the other hand: is heavy on features and content, but also heavy on bandwidth, and not responsive to screen size at all (960px FTW!)</p>
        <p class="note">Mobile traffic was growing quickly, and it was obvious that Yr needed a better experience for it's mobile web users</p>
        <p class="note step">Not surpisingly, it was decided that a single, responsive web site was the most future-proof strategy</p>
      </div>
    </section>

    <section id="architecture">
      <div class="bg"></div>
      <div class="diagram-group">
        <div class="diagram old">
          <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
            <circle class="renderer" opacity="0.5" cx="50" cy="50" r="50"/>
            <circle class="renderer" opacity="0.7" cx="50" cy="50" r="45"/>
            <circle class="renderer" cx="50" cy="50" r="40"/>
            <circle class="api" cx="50" cy="50" r="35"/>
            <circle class="data" cx="50" cy="50" r="30"/>
            <g class="text">
              <circle fill="none" cx="50" cy="50" r="60"/>
              <line x1="98" y1="12" x2="105" y2="5" />
              <line x1="110" y1="47" x2="120" y2="47" />
              <line x1="103" y1="82" x2="110" y2="89" />
              <text opacity="0.6" x="105" y="5">DATA</text>
              <text opacity="0.6" x="120" y="52">API</text>
              <text opacity="0.6" x="110" y="100">RENDERERS</text>
            </g>
          </svg>
        </div>
        <aside class="old-aside">
          <h3>no tests!</h3>
          <h3>2 week pre-release staging!</h3>
        </aside>
      </div>
      <div class="diagram new-renderer">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <circle class="renderer" cx="50" cy="50" r="25"/>
          <g class="text">
            <circle class="ring" fill="none" cx="50" cy="50" r="35"/>
            <line x1="76" y1="72" x2="85" y2="81" />
            <text opacity="0.6" x="85" y="92">RENDERER</text>
          </g>
        </svg>
      </div>
      <div class="diagram new-api">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <circle class="api" cx="50" cy="50" r="20"/>
          <circle class="api api-2" cx="50" cy="50" r="25"/>
          <g class="text">
            <circle fill="none" cx="50" cy="50" r="35"/>
            <line x1="85" y1="50" x2="98" y2="50" />
            <text opacity="0.6" x="95" y="56">API</text>
          </g>
        </svg>
      </div>
      <div class="diagram new-data">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <circle class="data" cx="50" cy="50" r="25"/>
          <g class="text">
            <circle fill="none" cx="50" cy="50" r="35"/>
            <line x1="73" y1="24" x2="80" y2="17" />
            <text opacity="0.6" x="80" y="17">DATA</text>
          </g>
        </svg>
      </div>
      <div class="notes">
        <p class="note">Before going any further, I should point out that the team at NRK responsible for the fifth most used weather service in the world, has always been quite small, and has never had more than 4 or 5 developers at any one time</p>
        <p class="note">In 2013, when I joined, there were only 3</p>
        <p class="note">Much of the code base at that time dated from the last redesign in 2010...</p>
        <p class="note step">...and it was a classic monolith: picture a large blob of data wrapped in a layer of XML, with several view layers for rendering mobile pages, desktop pages, app embedded views, svgs, pdfs, and who know what else</p>
        <p class="note">I wish I was here to talk about all the clever strategies we used to dismantle this beast, but the truth is: we were terrified of breaking anything, and this monster is still with us today</p>
        <p class="note step">The application was reliable, and had proven itself for many years, but there were very few tests (it was basically built with email-driven-development: errors and regressions were discoverd and reported by users), and it used to take 2 weeks to prepare new releases</p>
        <p class="note">This is a familiar story, and I'm a little ashamed to say that we played to type...</p>
        <p class="note step">...by starting over</p>
        <p class="note step">So instead of swapping out small pieces, we pulled out the largest part, which was all the place name data, into it's own service</p>
        <p class="note">Surprisingly, at least to me, is that there is actually very little weather related stuff happening inside the Yr application</p>
        <p class="note">Weather data comes from Met, and is mostly indexed by lat/long coordinate, so a large chunk of the application deals with matching a coordinate to a city, ski hill, your street, or any one of <strong>ten million</strong> places around the world</p>
        <p class="note">It's great to be able to expose this data to others (there are plans on making it public, for instance), but we really should have swapped out the existing data with this new service. We didn't, and now we're feeling the pain as old and new applications slowly drift out of sync</p>
        <p class="note step">Instead of slowly killing off the monolith, we pushed on and began building a REST API and view renderer for the new, responsive layout</p>
        <p class="note">Although this was already a big improvement, and we were now using a CI server to run tests and deploy to the cloud, our workflow for building the UI was really inefficient for such a small team:</p>
        <p class="note">I was delivering static versions of the front-end markup to my colleague to implement on the back-end, and we ended up duplicating a lot of the work associated with generating HTML</p>
        <p class="note step">So after a lot of grumbling, and a prototype while our project manager was on summer holiday, we decided to split the API and view renderer into separate projects</p>
        <p class="note step">Today, we have 4 monoliths</p>
      </div>
    </section>

    <section id="universal">
      <div class="bg"></div>
      <pre class="code more">
        <code class="js">
          const Node = function (less) {
            return Math.pow(less, 2);
          };
        </code>
      </pre>
      <div class="diagram server">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <rect x="10" y="0" width="80" height="100" vector-effect="non-scaling-stroke" />
          <rect x="80" y="8" width="4" height="4" />
          <line x1="10" y1="20" x2="90" y2="20" vector-effect="non-scaling-stroke" />
        </svg>
      </div>
      <div class="diagram client">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <rect x="20" y="0" width="60" height="100" rx="5" ry="5" vector-effect="non-scaling-stroke" />
          <line x1="20" y1="10" x2="80" y2="10" vector-effect="non-scaling-stroke" />
          <line x1="20" y1="90" x2="80" y2="90" vector-effect="non-scaling-stroke" />
          <circle cx="50" cy="95" r="2" vector-effect="non-scaling-stroke" />
        </svg>
      </div>
      <div class="diagram document">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <rect x="21" y="10" width="58" height="80" vector-effect="non-scaling-stroke" />
          <rect x="25" y="12" width="50" height="16" vector-effect="non-scaling-stroke" />
          <rect x="25" y="32" width="50" height="16" vector-effect="non-scaling-stroke" />
          <rect x="25" y="52" width="50" height="16" vector-effect="non-scaling-stroke" />
          <rect x="25" y="72" width="50" height="16" vector-effect="non-scaling-stroke" />
          <g class="loader">
            <circle cx="40" cy="40" r="2" />
            <circle cx="50" cy="40" r="2" />
            <circle cx="60" cy="40" r="2" />
          </g>
          <g class="content">
            <rect x="21" y="10" width="58" height="80" vector-effect="non-scaling-stroke" />
            <path d="M550 349C560, 342.3333333333333, 570, 313.1666666666667, 580, 306C590, 298.8333333333333, 600, 296.6666666666667, 610, 306C620, 315.3333333333333, 630, 355.1666666666667, 640, 362C650, 368.8333333333333, 660, 359, 670, 347" transform="translate(-195,-85) scale(0.4)" vector-effect="non-scaling-stroke" />
          </g>
        </svg>
      </div>
      <div class="titles">
        <h1 class="title title-1">JavaScript <span>up</span></h1>
        <h1 class="title title-2">JavaScript <span>down</span></h1>
        <h1 class="title title-3">JavaScript <span>all the way around</span></h1>
      </div>
      <div class="notes">
        <p class="note">This is NodeConf, so it shouldn't come as any surprise that the new Yr is powered by Node.js</p>
        <p class="note">And in 2016, this shouldn't come as a shock, but 18 months ago, at least at NRK, this wasn't the normal way to do things, certainly not for a site as popular as Yr</p>
        <p class="note step">But I was convinced, at least in this case, that we could get more done with less</p>
        <p class="note">Less time spent duplicating work, less time spent switching between contexts/platforms/languages, and less time spent getting content to users, is more time you can spend on making them happier</p>
        <p class="note step">Running JavaScript on the server with Node isn't really going to change the world, but it does give you more time to try</p>
        <p class="note step">And it's given me, the front-end guy, full control over rendering the UI, and the flexibility to decide where that rendering takes place</p>
        <p class="note step">Given our content, client-side rendering can be a real benefit to our users (for example, when switching between different locations, or between different visualisations), but I have 11,996 different reasons for wanting to be able to lean on server-side rendering</p>
        <p class="note">For us, rendering on the server on first request, and then rendering on the client for subsequent requests, is the fastest and most reliable way to get content to our users</p>
        <p class="note step">Some call this isomorphic, or universal...</p>
        <p class="note step">...but I like to call it: JavaScript Up...</p>
        <p class="note step">...JavaScript Down...</p>
        <p class="note step">...JavaScript All The Way Around</p>
      </div>
    </section>

    <section id="crap">
      <div class="bg"></div>
      <div class="points">
        <h3 class="point point-1">Cacheable</h3>
        <h3 class="point point-2">Resilient</h3>
        <h3 class="point point-3">Accessible</h3>
        <h3 class="point point-4">Progressive</h3>
      </div>
      <div class="notes">
        <p class="note">Server-side rendering is definitely more work if you also plan on rendering things on the client, but it has major advantages:</p>
        <p class="note step">It's cacheable: server generated content can be cached close to your users. This is good for speed, good for sudden traffic spikes, and good insurance against a server meltdown</p>
        <p class="note step">It's resilient: the browser is hostile territory, almost as hostile as the network, and delivering rendered content is good insurance against client-side meltdowns</p>
        <p class="note step">It's accessible: not all devices are created equal, and server rendering makes it easier to deliver content to as many as possible</p>
        <p class="note step">And it's progressive: delivering a baseline experience to all allows us to add additional features, and improve that experience, for those devices that <em>can</em> handle it. It's also easier to not worry about those that can't</p>
        <p class="note step">Add it all up, and it's <strong>CRAP</strong>! Having to do all this is a real pain in the ass</p>
        <p class="note">Caching is a nightmare; worrying about the resiliency of the network and our code is a headache; making content accessible on all those devices is impossible; and building things that can be progressively enhanced is hard</p>
        <p class="note">But honestly, most of us love crap: we love eating crap, we love watching crap, and we love spending a lot of time looking at crap on our phones</p>
        <p class="note step">So, do your users a favour, and make it CRAP, but not shit. They'll love you for it</p>
      </div>
    </section>

    <section id="express">
      <div class="bg"></div>
      <h2 class="abstract">URL >> handler >> data >> render >> HTML</h2>
      <pre class="code app">
        <code class="js">
          const app = express();
        </code>
      </pre>
      <pre class="code middleware">
        <code class="js">
          app.<span class="function">use</span>(function (req, res, next) {
            log('request from: ' + req.originalUrl);
            next();
          });
        </code>
      </pre>
      <pre class="code param">
        <code class="js">
          app.<span class="function">param</span>('localeCode', function (req, res, next, localeCode) {
            if (valid(localeCode)) return next();
            return next(Error('invalid locale code'));
          });
        </code>
      </pre>
      <pre class="code route">
        <code class="js">
          const pattern = '/:localeCode({localeCode})/:page({page})';

          app.<span class="function">get</span>(pattern, function (req, res, next) {
            const localeCode = req.params.localeCode;
            const query = req.query;
            //...
          });
        </code>
      </pre>
      <pre class="code url">
        <code class="js">
          "/en/search?q=foo"
        </code>
      </pre>
      <pre class="code anchor">
        <code class="html">
          &lt;a href="/en/search?q=foo"&gt;&lt;/a&gt;
        </code>
      </pre>
      <pre class="code handler">
        <code class="js">
          app.<span class="function">get</span>('/en/search', function (req, res, next) {
            const searchQuery = req.query.q;
            //...
          });
        </code>
      </pre>
      <ul class="crap">
        <li><span>★</span> all pages can be server rendered</li>
        <li><span>★</span> anchor tags work with or without JavaScript</li>
        <li><span>★</span> baseline content is available to every device</li>
        <li><span>★</span> can choose how much enhanced experience to offer</li>
      </ul>
      <div class="notes">
        <p class="note">Once I committed to making things crappier with server-side rendering, I needed to find a way to smooth over the differences between server and client code</p>
        <p class="note step">The logic flow on the server starts with a URL, and routes that URL to a handler, where you can fetch and munge some data, before finally rendering a string of HTML</p>
        <p class="note">This also seemed like a reasonable abstraction for the client</p>
        <p class="note step">So I wondered: would it be possible to initialize an application...</p>
        <p class="note step">...to add middleware...</p>
        <p class="note step">...to add request parameter validation...</p>
        <p class="note step">...and to handle a request, in the browser, just like Express.js does on the server?</p>
        <p class="note step">Well, it <em>is</em> possible, and it's actually a great way to think about program logic:</p>
        <p class="note step">URLs are fantastic for encapsulating state...</p>
        <p class="note step">...anchor tags are great triggers for transitioning between those states...</p>
        <p class="note step">...and Express is a simple and elegant way to route that new state to your logic</p>
        <p class="note">Whether it's a request captured by Node on the server, or a request captured by the History API on the client, all routing, validation, and handling logic is powered by the same basic Express code</p>
        <p class="note step">You may be wondering: how crappy can this approach really be?</p>
        <p class="note step">The server responds to all requests with rendered content</p>
        <p class="note">Anchor tags will still work without JavaScript, or with JavaScript that is behaving badly</p>
        <p class="note">All devices get the baseline content, and can follow links to other content</p>
        <p class="note">Not all devices need to run in a dynamic, enhanced mode, and even then, not all pages need to be rendered on the client (if there's no route enabled, throw a 404 and let the server render the resource)</p>
        <p class="note">That's some 4 star crap right there</p>
      </div>
    </section>

    <section id="data">
      <pre class="code shrug">
        <code class="js">
          const data = { ¯\_(ツ)_/¯ };
        </code>
      </pre>
      <pre class="code superagent">
        <code class="js">
          const request = require('superagent');

          app.<span class="function">get</span>(pattern, (req, res, next) => {
            //...
            request
              .<span class="function">get</span>('path/to/api')
              .<span class="function">end</span>((err, response) => {
                res.data = response.body;
                //...
              });
          });
        </code>
      </pre>
      <div class="notes">
        <p class="note">As far as data is concerned, if you're familiar with Express, then you know that it has few opinions about how you manage the data you might need to render a view</p>
        <p class="note">I don't have very strong opinions about it either. We've got lot's of it, and managing it can be really hard, but data is quite domain specific, so I'm going to skip over the details</p>
        <p class="note step">When loading data, however, I do recommend using a request library, like SuperAgent, that seamlessly supports both environments, as it makes sharing code between the server and client that much easier</p>
      </div>
    </section>

    <section id="render">
      <div class="bg"></div>
      <pre class="code render">
        <code class="js">
          res.<span class="function">render</span>('search', data, (err, html) => {
            res.<span class="function">send</span>(html);
          });
        </code>
      </pre>
      <pre class="code react-server">
        <code class="js">
          const pageContent = require('./pageContentComponent');

          // Server
          res.<span class="function">send</span>(ReactDOMServer.<span class="function">renderToString</span>(pageContent(props)));
        </code>
      </pre>
      <pre class="code react-client">
        <code class="js">
          // Client
          ReactDOM.<span class="function">render</span>(pageContent(props), pageElement);
        </code>
      </pre>
      <pre class="code mixins">
        <code class="js">
          const mixins = runtime.isBrowser
            ? [require('./interactiveStuff')]
            : [];
        </code>
      </pre>
      <div class="notes">
        <p class="note">Express does have some opinions about rendering HTML, but they are, fortunately, entirely optional</p>
        <p class="note step">2014 was the year of the component and React.js, and although they almost ruined things with .jsx, they <em>did</em> support server-side rendering...</p>
        <p class="note step">...and the opportunity to use the exact same component code on the server and client was really too tempting to pass up</p>
        <p class="note">At the time, they also favoured extending component behaviour with optional "mixins"...</p>
        <p class="note step">...which made it really easy to ignore all the logic for clicking, scrolling, and other user interaction on the server</p>
      </div>
    </section>

    <section id="react">
      <div class="bg"></div>
      <div class="phone iphone">
        <figure class="front">
          <img class="anim" src="src/images/iphone-paint.gif">
          <img class="frame" src="src/images/iphone-frame.png">
        </figure>
      </div>
      <h3 class="title">React and the economics of dynamic web interfaces<span>Nicholas C. Zakas</span></h3>
      <div class="quotes">
        <blockquote class="quote quote-1" cite="https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces">React has, ironically, allowed us to once again think about writing web applications as a series of pages rather than a monolithic blob of JavaScript code.</blockquote>
        <blockquote class="quote quote-2" cite="https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces">[...] it's the same mental model as traditional server-only applications. A page is rendered, some changes are requested, then a page is rendered with those changes. The only difference is that this can all happen client-side.</blockquote>
      </div>
      <h2 class="coverage">80% shared code</h2>
      <div class="notes">
        <p class="note">The technical parts of React are interesting, but the killer feature for me has always been that it makes it easy to render the whole tree on each state change</p>
        <p class="note step">This makes it possible to render from the root component even when only a small part of our data has changed</p>
        <p class="note">In this example, we're rendering the full page on each keypress, and after new data arrives from our API call, but the DOM repaint (shown here in green) is contained to the affected components</p>
        <p class="note">Although I considered this the best part of React, it wasn't until recently that I really appreciated why</p>
        <p class="note step">At the end of January this year, Nicholas Zakas published a blog post called "React and the economics of dynamic web interfaces"</p>
        <p class="note">In it, he outlined his thoughts about how React has changed the performance, efficiency, and complexity costs associated with dynamic DOM updates</p>
        <p class="note step">QUOTE: React has, ironically, allowed us to once again think about writing web applications as a series of pages rather than a monolithic blob of JavaScript code</p>
        <p class="note step">QUOTE: it's the same mental model as traditional server-only applications. A page is rendered, some changes are requested, then a page is rendered with those changes. The only difference is that this can all happen client-side</p>
        <p class="note step">If client-side Express was the lightning, this, for me, was the thunder</p>
        <p class="note">The one-two punch of Express and React made it possible to understand and manage program flow on the client just as you would on the server, and that was a very big idea</p>
        <p class="note">I'm not suggesting that this is the answer to everyone's prayers, but I think that applying a server model to the client can be a really elegant solution...</p>
        <p class="note step">...with the major practical benefit for us being that we now have a codebase that is 80% shared between server and client, and I now spend very little time and mental energy switching between the two</p>
      </div>
    </section>

    <section id="serviceWorker">
      <div class="bg"></div>
      <pre class="code service-worker">
        <code class="js">
          if ('serviceWorker' in navigator) {
            // Node all the things!
          }
        </code>
      </pre>
      <pre class="code express-worker">
        <code class="js">
          navigator.serviceWorker.<span class="function">register</span>('/sw.js')
            .then(function(registration) {
              const app = express();
              // ...
            });
        </code>
      </pre>
      <div class="notes">
        <p class="note">Predicting the future is a difficult and sometimes dangerous game, but it's hard to ignore the obvious signs that the font-end is coming to look a lot more like the back-end</p>
        <p class="note step">If you were at Web Rebels the last couple of days, or if you've been following along with the news lately, you know that the new Service Worker API has arrived, and it's put a proxy server in your browser</p>
        <p class="note">Every client request can now be handled right on the device, whether there is a network connection or not. This is a big deal, and I think it really validates this server-centric approach</p>
        <p class="note step">I'm not exactly sure what this will look like yet, but I'm excited that the future of the web is looking a lot like it's server-rendered past</p>
      </div>
    </section>

    <section id="node">
      <div class="stats">
        <h3>Node in production (last 7 days)</h3>
        <ul>
          <li><span>5.66</span> million requests</li>
          <li><span>1000</span>ms response latency (95th percentile)</li>
          <li><span>0.05</span>% error rate</li>
        </ul>
      </div>
      <div class="charts">
        <img src="src/images/render-list.png">
        <img src="src/images/render-graph.png">
      </div>
      <pre class="code render">
        <code class="js">
          ReactDOMServer.<span class="function">renderToString</span>(pageContent(props));
        </code>
      </pre>
      <ul class="tips">
        <li class="tip tip-1 good">
          <h3>Set production mode</h3>
          <pre class="code">
            <code class="bash">
              $ NODE_ENV=production node index.js
            </code>
          </pre>
        </li>
        <li class="tip tip-2 good">
          <h3>Use minified React</h3>
          <pre class="code">
            <code class="js">
              const React = require('react/dist/react.min');
            </code>
          </pre>
        </li>
        <li class="tip tip-3 good">
          <h3>Render components as "stateless functions"</h3>
          <pre class="code">
            <code class="js">
              const render = (props) => {
                return React.DOM.<span class="function">h1</span>(props.title);
              };
            </code>
          </pre>
        </li>
        <li class="tip tip-4 maybe">
          <h3>Render components in a child process</h3>
          <pre class="code">
            <code class="js">
              const renderer = require('child_process')
                .<span class="function">fork</span>('./renderer.js');
            </code>
          </pre>
        </li>
      </ul>
      <h3 class="issue">Proposal: ReactDOMServer render to Stream <span>#6420</span></h3>
      <div class="notes">
        <p class="note">When planning this talk, I kept struggling with the fact that, since this is NodeConf, I should talk about Node, but Node is actually the most boring part of our story</p>
        <p class="note step">Running Node in production has so far been largely uneventful. Last week we processed 5.66 million requests, our response latency was around 1000ms for the 95th percentile, and our error rate was 0.05%</p>
        <p class="note">I've tried to spice things up a little by running the latest version of Node 6, with all the new ES6 syntax it supports, but it's still a rather boring story</p>
        <p class="note step">Boring is good for production, of course, and production is great for generating data, which helps me understand exactly how things behave in the real world...</p>
        <p class="note">...and the real world has taught me that server-side React is disappointingly <em>slow</em></p>
        <p class="note">These charts capture an hour's worth of render times for the main page component of the List and Graph pages: times vary roughly between 50 and 100 ms</p>
        <p class="note step">This is quite bad, but it's actually worse when you consider that the call to <em>renderToString</em> is a blocking, synchronous call! That effectively means our Node process is unable to handle any other requests while rendering</p>
        <p class="note">So our hack to make the server look a little more like the client could end up hurting us</p>
        <p class="note step">There are a few tricks you can try to improve things:</p>
        <p class="note step">...be sure to run in <em>production</em> mode (which is generally good practice for most things, not just React)</p>
        <p class="note step">...use the minified version of React</p>
        <p class="note step">...render all components as <em>stateless functions</em> (that is, components should not inherit from React.Component or React.createClass)</p>
        <p class="note step">...and maybe render components in a child process? I haven't tried this yet, but I'm tempted, though there are probably costs associated with serializing/de-serializing data</p>
        <p class="note">What React badly needs is an asynchronous renderer</p>
        <p class="note step">Fortunately, work has begun on an asynchronous, streaming renderer, and although some core team members are sceptical, it looks like React may eventually get improved server-side rendering</p>
      </div>
    </section>

    <section id="summary">
      <ul class="lessons">
        <li class="lesson lesson-1 good">weather is a growth industry</li>
        <li class="lesson lesson-2 maybe">North Koreans agree: Yr is great!</li>
        <li class="lesson lesson-3 bad">kill off your monolith slowly</li>
        <li class="lesson lesson-4 good">Node.js is boring!</li>
        <li class="lesson lesson-5 good">server-side rendering is CRAP!</li>
        <li class="lesson lesson-6 good">CRAP is good for users</li>
        <li class="lesson lesson-7 good">client-side Express.js works</li>
        <li class="lesson lesson-8 good">client-side React.js changes the equation</li>
        <li class="lesson lesson-9 bad">server-side React.js makes things slow</li>
        <li class="lesson lesson-10 good">Express.js + React.js are like thunder + lightning</li>
        <li class="lesson lesson-11 good">your <em>Server</em> Worker is here</li>
      </ul>
      <div class="phone iphone">
        <figure class="front">
          <img class="anim" src="src/images/iphone-screencap.gif">
          <img class="frame" src="src/images/iphone-frame.png">
        </figure>
      </div>
      <div class="phone n95">
        <figure class="front ">
          <img src="src/images/n95-new.png">
        </figure>
      </div>
      <div class="notes">
        <p class="note">It's been a long journey, so what have I learned?</p>
        <p class="note step">Weather is a growth industry</p>
        <p class="note step">Yr is big in North Korea</p>
        <p class="note step">You should probably kill your monolith off slowly</p>
        <p class="note step">Node.js is boring, and that's good</p>
        <p class="note step">Server-side rendering is CRAP, and that's great</p>
        <p class="note step">Cacheability, Reliability, Accessibility, and Progressiveness are good for users</p>
        <p class="note step">Client-side Express.js is a great way to structure program logic</p>
        <p class="note step">Client-side React.js changes the costs of rendering, which gives us the freedom to think like a server</p>
        <p class="note step">Server-side React.js is a nice hack to make the server more client-like, but it's slow</p>
        <p class="note step">Together, Express and React shake me up like thunder and lightning</p>
        <p class="note step">And finally, Service Worker is here to put even more server goodness in the browser</p>
      </div>
    </section>

    <section id="bye">
      <div class="bg"></div>
      <h1>
        Thanks!
        <a href="https://twitter.com/popeindustries">@popeindustries</a>
      </h1>
      <div class="references">
        <h3>Slides</h3>
        <a href="http://popeindustries.github.io/nodeconf-oslo-2016">http://popeindustries.github.io/nodeconf-oslo-2016</a>
        <h3>Links</h3>
        <a href="https://github.com/YR/express-client">https://github.com/YR/express-client</a>
        <a href="https://github.com/YR/component">https://github.com/YR/component</a>
        <a href="https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces">https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces</a>
        <a href="https://github.com/facebook/react/issues/6420">https://github.com/facebook/react/issues/6420</a>
        <a href="https://github.com/facebook/react/pull/6618">https://github.com/facebook/react/pull/6618</a>
      </div>
      <footer>
        <p>PHOTOS: Alexander Pope</p>
      </footer>
      <div class="notes">
        <p class="note">I'm forecasting sunny days ahead!</p>
        <p class="note step">Thanks for listening, and thanks to the organisers for having me!</p>
      </div>
    </section>
  </div>
  <div class="clock"></div>
  <script src="src/lib/highlight.js"></script>
  <script src="index.js"></script>
</body>
</html>