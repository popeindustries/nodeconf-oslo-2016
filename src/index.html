<!DOCTYPE html>
<html class="">
<head>
  <meta charset="utf-8">
  <title>NodeConf Oslo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
  <link rel="stylesheet" type="text/css" href="index.css">
  <link rel="stylesheet" type="text/css" href="src/lib/monokai.css">
  <link rel="stylesheet" type="text/css" href="src/lib/monokai-sublime.css">
</head>
<body>
  <div class="slides">
    <section id="title">
      <div class="top">
        <h1>Thunder</h1>
      </div>
      <div class="middle">
        <h1>&amp;</h1>
      </div>
      <div class="bottom">
        <h1>Lightning</h1>
      </div>
      <div class="notes">
        <p class="note">Hi, I'm Alex, and today I wanted to talk to you about thunder, lightning, and a Norwegian weather service called Yr</p>
      </div>
    </section>

    <section id="history">
      <img class="logo logo--yr" inline src="src/images/logo-yr--circle.svg">
      <div class="partner-logos">
        <img class="logo logo--nrk" inline src="src/images/logo-nrk.svg">
        <img class="logo logo--met" inline src="src/images/logo-met.svg">
      </div>
      <h3 class="max-users">9,000,000 users/week</h3>
      <img class="stats" inline src="src/images/stats.svg">
      <h3 class="launch-date">Sept 19, 2007</h3>
      <h3 class="mobile-users">60% mobile</h3>
      <div class="notes">
        <p class="note"></p>
        <p class="note step">Yr is a collaboration between Norway's state broadcaster, NRK, (where I work) and the state Meteorological Institute, Met</p>
        <p class="note">NRK and Met have collaborated to deliver weather reports to Norwegians since forever, first via radio, then TV</p>
        <p class="note">In 2006, Met decided to make it's data freely available to the public. North Americans have always enjoyed free access to weather data, but in Europe, that wasn't the case until the Norwegians made their move. Shortly after that, NRK and Met released Yr</p>
        <p class="note step">The service quickly became one of the most used in Norway...</p>
        <p class="note step">...and last summer had 9 million (unique) visitors per week...</p>
        <p class="note step">...of which roughly 60% was mobile traffic (evenly split between web and native apps), on 11,996 different devices</p>
      </div>
    </section>

    <section id="geography">
      <img class="map" inline src="src/images/map.svg">
      <h2 class="title">web sessions (2015)</h2>
      <h3 class="no-users">578,850,000 from Norway (47%)</h3>
      <h3 class="nk-users">31 from North Korea</h3>
      <div class="notes">
        <p class="note">Now, there are only 5 million people living in Norway, so the question is "where does all this traffic come from?"</p>
        <p class="note step">According to Google, the answer would be everywhere except, apparently, Western Sahara</p>
        <p class="note step">Norway accounts for a little under 50% of the traffic, with most of the remaining top 10 coming from northern Europe. </p>
        <p class="note">Strangely, Yr is big with South African farmers, and though it's <em>not</em> so big in Japan...</p>
        <p class="note step">...31 sessions were recorded from North Korea, so I'm calling that big in North Korea</p>
      </div>
    </section>

    <section id="mobile">
      <div class="phone n95">
        <figure class="front ">
          <img src="src/images/n95-old.png">
          <figcaption>2007</figcaption>
        </figure>
      </div>
      <div class="phone iphone">
        <figure class="front">
          <img src="src/images/iphone-old.png">
          <figcaption>2013</figcaption>
        </figure>
        <figure class="back">
          <img src="src/images/iphone-old-www.png">
          <figcaption>2013</figcaption>
        </figure>
      </div>
      <div class="m">
        <h3>m.yr.no</h3>
        <ul>
          <li class="good">light on bandwidth</li>
          <li class="good">flexible width</li>
          <li class="bad">light on features</li>
        </ul>
      </div>
      <div class="www">
        <h3>www.yr.no</h3>
        <ul>
          <li class="good">heavy on features</li>
          <li class="bad">heavy on bandwidth</li>
          <li class="bad">fixed width</li>
        </ul>
      </div>
      <div class="notes">
        <p class="note"></p>
        <p class="note step">In 2007, if you fired-up your top-of-the-line Nokia N95, the website would have looked something like this</p>
        <p class="note step">Unfortunately, in 2013, it would still have looked something like this...</p>
        <p class="note step">...though with a little bit of work, you could opt for the desktop version instead</p>
        <p class="note step">The mobile version had a lot going for it: it was light on bandwidth, and it worked well on small screens, but it was also very light on features</p>
        <p class="note step">The desktop version, on the other hand: is heavy on features and content, but also heavy on bandwidth, and not responsive to screen size at all</p>
        <p class="note">Mobile traffic was growing quickly, and it was obvious that Yr needed to offer a better experience for it's mobile web users</p>
        <p class="note step">Unsurpisingly, it was decided that a single, responsive web site was the most future-proof strategy</p>
      </div>
    </section>

    <section id="architecture">
      <div class="bg"></div>
      <div class="diagram-group">
        <div class="diagram old">
          <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
            <circle class="renderer" opacity="0.5" cx="50" cy="50" r="50"/>
            <circle class="renderer" opacity="0.7" cx="50" cy="50" r="45"/>
            <circle class="renderer" cx="50" cy="50" r="40"/>
            <circle class="api" cx="50" cy="50" r="35"/>
            <circle class="data" cx="50" cy="50" r="30"/>
            <g class="text">
              <circle fill="none" cx="50" cy="50" r="60"/>
              <line x1="98" y1="12" x2="105" y2="5" />
              <line x1="110" y1="47" x2="120" y2="47" />
              <line x1="103" y1="82" x2="110" y2="89" />
              <text opacity="0.6" x="105" y="5">DATA</text>
              <text opacity="0.6" x="120" y="52">API</text>
              <text opacity="0.6" x="110" y="100">RENDERERS</text>
            </g>
          </svg>
        </div>
        <aside class="old-aside">
          <h3>no tests!</h3>
          <h3>2 week pre-release staging!</h3>
        </aside>
      </div>
      <div class="diagram new-renderer">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <circle class="renderer" cx="50" cy="50" r="25"/>
          <g class="text">
            <circle class="ring" fill="none" cx="50" cy="50" r="35"/>
            <line x1="76" y1="72" x2="85" y2="81" />
            <text opacity="0.6" x="85" y="92">RENDERER</text>
          </g>
        </svg>
      </div>
      <div class="diagram new-api">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <circle class="api" cx="50" cy="50" r="20"/>
          <circle class="api api-2" cx="50" cy="50" r="25"/>
          <g class="text">
            <circle fill="none" cx="50" cy="50" r="35"/>
            <line x1="85" y1="50" x2="98" y2="50" />
            <text opacity="0.6" x="95" y="56">API</text>
          </g>
        </svg>
      </div>
      <div class="diagram new-data">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <circle class="data" cx="50" cy="50" r="25"/>
          <g class="text">
            <circle fill="none" cx="50" cy="50" r="35"/>
            <line x1="73" y1="24" x2="80" y2="17" />
            <text opacity="0.6" x="80" y="17">DATA</text>
          </g>
        </svg>
      </div>
      <div class="notes">
        <p class="note">In 2013, I joined the team as a front-end developer and designer</p>
        <p class="note">Now, I should point out that the team at NRK responsible for the fifth most used weather service in the world, has never had more than 5 developers at any one time, and up to that point, there had never been more than 3</p>
        <p class="note">So, much of the code base at that time dated from the last redesign in 2010...</p>
        <p class="note step">...and it was a classic monolith: picture a large blob of data wrapped in a layer of XML, with several view layers for rendering mobile pages, desktop pages, app embedded views, svgs, pdfs, and who know what else</p>
        <p class="note">I wish I was here to tell you all about the clever strategies we used to carefully and precisely dismantle this beast, but the truth is: we were terrified of breaking anything, and the monster still lives</p>
        <p class="note step">The application was reliable, and had proven itself for many years, but there were very few tests (the joke was that it was built with email-driven-development: users would report errors and regressions via email), and it took 2 weeks to prepare new releases</p>
        <p class="note">This is a story plot we have heard many times, and I'm a little ashamed to say that we played to type...</p>
        <p class="note step">...by starting over</p>
        <p class="note step">The first step was pulling out all the place name data into it's own service</p>
        <p class="note">Surprisingly, at least to me, is that there is actually very little weather related stuff happening in there. Weather data comes from Met, and is mostly indexed by lat/long coordinate, so a large chunk of the application deals with matching a coordinate to a city, ski hill, your street, or any one of <strong>ten million</strong> places around the world</p>
        <p class="note">It's great to be able to expose this data to others (there are plans on making it public), and we should have replaced the existing data with this new service, but we didn't, and we're now feeling the pain as old and new applications are slowly drifting out of sync</p>
        <p class="note step">Instead, we pushed on and began building a REST API and view renderer for the new, responsive layout</p>
        <p class="note">Although this was already a big improvement, and we were now using a CI server to run tests and deploy to the cloud, our workflow for building the UI was really inefficient for such a small team: I was delivering static versions of the front-end markup to my colleague to implement on the back-end, and we ended up duplicating a lot of the work associated with generating HTML</p>
        <p class="note step">So after a lot of grumbling, and a skunkworks prototype while our project manager was on summer holiday, we decided to split the API and view renderer into separate projects</p>
        <p class="note step">Now we have 4 monoliths</p>
      </div>
    </section>

    <section id="universal">
      <div class="bg"></div>
      <div class="titles">
        <h1 class="title title-1">JavaScript <span>up</span></h1>
        <h1 class="title title-2">JavaScript <span>down</span></h1>
        <h1 class="title title-3">JavaScript <span>all the way around</span></h1>
      </div>
      <div class="notes">
        <p class="note">This is NodeConf, so it shouldn't come as any surprise that the new Yr is powered by Node.js</p>
        <p class="note">And in 2016, this shouldn't come as a shock, but 18 months ago, at least at NRK, this wasn't the normal way to do things, certainly not for a site as popular as Yr</p>
        <p class="note">Now, I'm no scientist - just a web developer - but I've been doing web stuff for some time now, and I'm convinced you can usually get more done with less</p>
        <p class="note">Less time spent duplicating work, less time spent switching between contexts/platforms/languages, and less time spent getting content to users, is more time you can spend on making them happier</p>
        <p class="note step">Running JavaScript on the server with Node isn't really going to change the world, but it does give you more time to try</p>
        <p class="note">And it's given me, the front-end guy, the ability to control the UI rendering lifecyle, and the flexibility to decide where that rendering takes place</p>
        <p class="note">I think that, because of our content, many of our users could benefit from client-side rendering (switching between different locations, or switching between different visualisations, for example), but I have 11,996 different reasons for wanting to be able to lean on server-side rendering</p>
        <p class="note">For us, rendering on the server on first request, and then rendering on the client for subsequent requests, is the fastest and most reliable way to get content to our users</p>
        <p class="note">Some call this isomorphic, or universal...</p>
        <p class="note step">...but I like to call it: JavaScript Up...</p>
        <p class="note step">...JavaScript Down...</p>
        <p class="note step">...JavaScript All The Way Around</p>
      </div>
    </section>

    <section id="crap">
      <div class="bg"></div>
      <div class="points">
        <h3 class="point point-1">Cacheable</h3>
        <h3 class="point point-2">Resilient</h3>
        <h3 class="point point-3">Accessible</h3>
        <h3 class="point point-4">Progressive</h3>
      </div>
      <div class="notes">
        <p class="note">Server-side rendering is definitely more work if you also plan on rendering things on the client, but it has major advantages:</p>
        <p class="note step">It's cacheable: server generated content can be cached close to your users. This is good for speed, good for sudden traffic spikes, and good insurance against a server meltdown</p>
        <p class="note step">It's resilient: the browser is hostile territory, almost as hostile as the network, and delivering rendered content is good insurance against client-side meltdowns</p>
        <p class="note step">It's accessible: not all devices are created equal, and server rendering makes it easier to deliver content to as many as possible</p>
        <p class="note step">And it's progressive: delivering a baseline experience to all allows us to add additional features, and improve that experience, for those devices that <em>can</em> handle it. It's also easier to not worry about those that can't</p>
        <p class="note step">Add it all up, and it's <strong>CRAP</strong>! Having to do all this is a real pain in the ass</p>
        <p class="note">Caching is nightmare; worrying about the resiliency of the network and our code is a headache; making content accessible on all those devices is impossible; and building things that can be progressively enhanced is hard</p>
        <p class="note">But honestly, most of us love crap: we eat crap, we watch crap, and we spend a lot of time looking at crap on our phones</p>
        <p class="note step">So, do your users a favour, and make it CRAP, but not shit. They'll love you for it</p>
      </div>
    </section>

    <section id="express">
      <div class="bg"></div>
      <h2 class="abstract">URL >> handler >> data >> render >> HTML</h2>
      <pre class="code app">
        <code class="js">
          const app = express();
        </code>
      </pre>
      <pre class="code middleware">
        <code class="js">
          app.<span class="function">use</span>(function (req, res, next) {
            log('request from: ' + req.originalUrl);
            next();
          });
        </code>
      </pre>
      <pre class="code param">
        <code class="js">
          app.<span class="function">param</span>('localeCode', function (req, res, next, localeCode) {
            if (valid(localeCode)) return next();
            return next(Error('invalid locale code'));
          });
        </code>
      </pre>
      <pre class="code route">
        <code class="js">
          const pattern = '/:localeCode({localeCode})/:page({page})';

          app.<span class="function">get</span>(pattern, function (req, res, next) {
            const localeCode = req.params.localeCode;
            const query = req.query;
            //...
          });
        </code>
      </pre>
      <pre class="code url">
        <code class="js">
          "/en/search?q=foo"
        </code>
      </pre>
      <pre class="code anchor">
        <code class="html">
          &lt;a href="/en/search?q=foo"&gt;&lt;/a&gt;
        </code>
      </pre>
      <pre class="code handler">
        <code class="js">
          app.<span class="function">get</span>('/en/search', function (req, res, next) {
            const searchQuery = req.query.q;
            //...
          });
        </code>
      </pre>
      <div class="notes">
        <p class="note">Once I committed to making things crappier with server-side rendering, I needed to find a way to smooth over the differences between server and client code</p>
        <p class="note step">The logic flow on the server starts with a URL, and routes that URL to a handler, where you can fetch and munge some data, before finally rendering a string of HTML</p>
        <p class="note">This also seemed like a reasonable abstraction for the client</p>
        <p class="note step">So I wondered: would it be possible to initialize an application...</p>
        <p class="note step">...to add middleware...</p>
        <p class="note step">...to add request parameter validation...</p>
        <p class="note step">...and to handle a request, in the browser, just like Express.js does on the server?</p>
        <p class="note step">Well, it <em>is</em> possible, and it's actually a great way to think about program logic:</p>
        <p class="note step">URLs are fantastic for encapsulating state...</p>
        <p class="note step">...anchor tags are great triggers for transitioning between those states...</p>
        <p class="note step">...and Express is a simple and elegant way to route this state to a logic handler</p>
        <p class="note">Today, whether it's a request captured by Node on the server, or a request captured by the History API on the client, all routing, validation, and handling logic is powered by the same basic Express code</p>
        <p class="note step">Treating program flow on the client in a similar way as on the server has reduced the cost for me of switching between contexts, and has had an added benefit of leveraging the power of URLs, which ultimately help make things super CRAP, which is super good</p>
      </div>
    </section>

    <section id="data">
      <pre class="code shrug">
        <code class="js">
          const data = { ¯\_(ツ)_/¯ };
        </code>
      </pre>
      <pre class="code freeze">
        <code class="js">
          if (isDevelopment) data = deepFreeze(deepClone(data));
        </code>
      </pre>
      <pre class="code superagent">
        <code class="js">
          const request = require('superagent');

          app.<span class="function">get</span>(pattern, (req, res, next) => {
            //...
            request
              .<span class="function">get</span>('path/to/api')
              .<span class="function">end</span>((err, response) => {
                res.data = response.body;
                //...
              });
          });
        </code>
      </pre>
      <div class="notes">
        <p class="note">As far as data is concerned, if you're familiar with Express, then you know that it has few opinions about how you manage the data you might need to render a view</p>
        <p class="note">I don't have very strong opinions about it either. We've got lot's of it, and managing it can be really hard, but data is quite domain specific, so I won't bore you with the details</p>
        <p class="note step">I will say, though, that using some sort of immutable data can be a smart thing to do, and it doesn't have to be more difficult than a recursive Object.freeze in dev mode</p>
        <p class="note step">I also recommend using a request library, like SuperAgent, that seamlessly supports both environments, as it makes sharing code between the server and client much easier</p>
      </div>
    </section>

    <section id="render">
      <div class="bg"></div>
      <pre class="code render">
        <code class="js">
          res.<span class="function">render</span>('search', data, (err, html) => {
            res.<span class="function">send</span>(html);
          });
        </code>
      </pre>
      <pre class="code react-server">
        <code class="js">
          const pageContent = require('./pageContentComponent');

          // Server
          res.<span class="function">send</span>(ReactDOMServer.<span class="function">renderToString</span>(pageContent(props)));
        </code>
      </pre>
      <pre class="code react-client">
        <code class="js">
          // Client
          ReactDOM.<span class="function">render</span>(pageContent(props), pageElement);
        </code>
      </pre>
      <pre class="code mixins">
        <code class="js">
          const mixins = runtime.isBrowser
            ? [require('./interactiveStuff')]
            : [];
        </code>
      </pre>
      <div class="notes">
        <p class="note">Express does have some opinions about rendering, but they are, fortunately, entirely optional</p>
        <p class="note step">2014 was the year of the component and React.js, and although they tried to ruin things with .jsx, they <em>did</em> support server-side rendering...</p>
        <p class="note step">...and the opportunity to use the exact same component code on the server and client was too tempting to pass up</p>
        <p class="note">At the time, they also favoured extending component behaviour with optional "mixins"...</p>
        <p class="note step">...which made it really easy to ignore all the logic for clicking, scrolling, and other user interaction on the server</p>
      </div>
    </section>

    <section id="react">
      <div class="bg"></div>
      <div class="phone iphone">
        <figure class="front">
          <img class="anim" src="src/images/iphone-paint.gif">
          <img class="frame" src="src/images/iphone-frame.png">
        </figure>
      </div>
      <h3 class="title">React and the economics of dynamic web interfaces<span>Nicholas C. Zakas</span></h3>
      <div class="quotes">
        <blockquote class="quote quote-1" cite="https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces">React has, ironically, allowed us to once again think about writing web applications as a series of pages rather than a monolithic blob of JavaScript code.</blockquote>
        <blockquote class="quote quote-2" cite="https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces">[...] it's the same mental model as traditional server-only applications. A page is rendered, some changes are requested, then a page is rendered with those changes. The only difference is that this can all happen client-side.</blockquote>
      </div>
      <h2 class="coverage">80% shared code</h2>
      <div class="notes">
        <p class="note">The technical parts of React are interesting, but the killer feature for me has always been that it makes it easy to render the whole tree on each state change</p>
        <p class="note step">This makes it possible to render from the root component even when only a small part of our data has changed</p>
        <p class="note">In this example, we're rendering the full page on each keypress, and after new data arrives from our api call, but the DOM repaint (shown here in Green) is contained to the affected components</p>
        <p class="note">Although I considered this the best part of React, it wasn't until recently that I really appreciated why</p>
        <p class="note step">At the end of January this year, Nicholas Zakas published a blog post called "React and the economics of dynamic web interfaces"</p>
        <p class="note">In it, he outlined his thoughts about how React has changed the performance, efficiency, and complexity costs associated with dynamic DOM updates</p>
        <p class="note step">QUOTE: React has, ironically, allowed us to once again think about writing web applications as a series of pages rather than a monolithic blob of JavaScript code</p>
        <p class="note step">QUOTE: it's the same mental model as traditional server-only applications. A page is rendered, some changes are requested, then a page is rendered with those changes. The only difference is that this can all happen client-side</p>
        <p class="note step">If client-side Express was the lightning, this, for me, was the thunder</p>
        <p class="note">The one-two punch of Express and React made it possible to understand and manage program flow on the client just as you would on the server, and that was a very powerful idea for me</p>
        <p class="note">I'm not suggesting that this is the answer to everyone's prayers, but I think that applying a server model to the client can be a really elegant solution...</p>
        <p class="note step">...with a major practical benefit being that we now have a codebase that is 80% shared between server and client, and I now spend very little time and mental energy switching between the two</p>
      </div>
    </section>

    <section id="caveats">
      <div class="charts">
        <img src="src/images/render-list.png">
        <img src="src/images/render-graph.png">
      </div>
      <pre class="code render">
        <code class="js">
          ReactDOMServer.<span class="function">renderToString</span>(pageContent(props));
        </code>
      </pre>
      <ul class="tips">
        <li class="tip tip-1 good">
          <h3>Set production mode</h3>
          <pre class="code">
            <code class="bash">
              $ NODE_ENV=production node index.js
            </code>
          </pre>
        </li>
        <li class="tip tip-2 good">
          <h3>Use minified React</h3>
          <pre class="code">
            <code class="js">
              const React = require('react/dist/react.min');
            </code>
          </pre>
        </li>
        <li class="tip tip-3 good">
          <h3>Render components as "stateless functions"</h3>
          <pre class="code">
            <code class="js">
              const render = (props) => {
                return React.DOM.<span class="function">h1</span>(props.title);
              };
            </code>
          </pre>
        </li>
        <li class="tip tip-4 maybe">
          <h3>Render components in a child process</h3>
          <pre class="code">
            <code class="js">
              const renderer = require('child_process')
                .<span class="function">fork</span>('./renderer.js');
            </code>
          </pre>
        </li>
      </ul>
      <h3 class="issue">Proposal: ReactDOMServer render to Stream <span>#6420</span></h3>
      <div class="notes">
        <p class="note">Now, this make for a nice story, but real life - and by real life I mean <em>production</em> - is not always so neat and tidy</p>
        <p class="note step">It turns out that server-side React is actually very <em>slow</em></p>
        <p class="note">These charts capture an hour's worth of render times for the main page component of the List and Graph pages: times vary roughly between 50 and 100 ms</p>
        <p class="note step">This is quite bad, but it's actually worse when you consider that the call to <em>renderToString</em> is a blocking, synchronous call! That effectively means our Node process is unable to handle any other requests while rendering</p>
        <p class="note step">There are a few tricks you can try to improve things:</p>
        <p class="note step">...be sure to run in <em>production</em> mode (generally good practice for all libraries, not just React)</p>
        <p class="note step">...use the minified version of React</p>
        <p class="note step">...render all components as <em>stateless functions</em> (that is, components should not inherit from React.Component or React.createClass)</p>
        <p class="note step">...and maybe render components in a child process? I haven't tried this yet, but I'm tempted, though there are probably costs associated with serializing/de-serializing data</p>
        <p class="note">What React badly needs is an asynchronous renderer</p>
        <p class="note step">Fortunately, work has begun on an asynchronous, streaming renderer, and although some core team members are sceptical, it looks like React may eventually get improved server-side rendering</p>
      </div>
    </section>

    <section id="summary">
      <div class="phone iphone">
        <figure class="front">
          <img class="anim" src="src/images/iphone-screencap.gif">
          <img class="frame" src="src/images/iphone-frame.png">
        </figure>
      </div>
      <div class="phone n95">
        <figure class="front ">
          <img src="src/images/n95-new.png">
        </figure>
      </div>
      <div class="notes">
        <p class="note">It's been a long journey, and a little rough weather on the way was to be expected, but things are looking bright</p>
        <p class="note">Server-side rendering with Node is keeping things CRAP (cacheable, resilient, accessible, and progressive)...</p>
        <p class="note">...Express and React are making it possible to use the same mental model on both sides of the wire...</p>
        <p class="note">...and there are a lot of exciting things on the horizon</p>
      </div>
    </section>

    <section id="bye">
      <div class="bg"></div>
      <h1>
        Thanks!
        <a href="https://twitter.com/popeindustries">@popeindustries</a>
      </h1>
      <div class="references">
        <h3>Slides</h3>
        <a href="http://popeindustries.github.io/nodeconf-oslo-2016">http://popeindustries.github.io/nodeconf-oslo-2016</a>
        <h3>Links</h3>
        <a href="https://github.com/YR/express-client">https://github.com/YR/express-client</a>
        <a href="https://github.com/YR/component">https://github.com/YR/component</a>
        <a href="https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces">https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces</a>
        <a href="https://github.com/facebook/react/issues/6420">https://github.com/facebook/react/issues/6420</a>
        <a href="https://github.com/facebook/react/pull/6618">https://github.com/facebook/react/pull/6618</a>
      </div>
      <footer>
        <p>PHOTOS: Alexander Pope</p>
      </footer>
      <div class="notes">
        <p class="note">I'm forecasting sunny days ahead!</p>
        <p class="note">Thanks for listening, and thanks to the organisers for having me</p>
        <p class="note step">You can find the presentation slides here, along with some relevant links</p>
        <p class="note">Feel free to reach out on Twitter or GitHub if you have any questions, and if any of this sounds exciting, we're always looking for help!</p>
      </div>
    </section>
  </div>
  <script src="src/lib/highlight.js"></script>
  <script src="index.js"></script>
</body>
</html>