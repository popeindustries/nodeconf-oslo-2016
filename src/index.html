<!DOCTYPE html>
<html class="">
<head>
  <meta charset="utf-8">
  <title>NodeConf Oslo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
  <link rel="stylesheet" type="text/css" href="index.css">
  <link rel="stylesheet" type="text/css" href="src/lib/monokai.css">
  <link rel="stylesheet" type="text/css" href="src/lib/monokai-sublime.css">
</head>
<body>
  <div class="slides">
    <section id="title">
      <div class="top">
        <h1>Thunder</h1>
      </div>
      <div class="middle">
        <h1>&amp;</h1>
      </div>
      <div class="bottom">
        <h1>Lightning</h1>
      </div>
      <div class="notes">
        <p class="note">Hi, I'm Alex, and I'm here today to talk about thunder, lightning, and the weather</p>
      </div>
    </section>

    <section id="history">
      <img class="logo logo--yr" inline src="src/images/logo-yr--circle.svg">
      <div class="partner-logos">
        <img class="logo logo--nrk" inline src="src/images/logo-nrk.svg">
        <img class="logo logo--met" inline src="src/images/logo-met.svg">
      </div>
      <h3 class="max-users">9,000,000 users/week</h3>
      <img class="stats" inline src="src/images/stats.svg">
      <h3 class="launch-date">Sept 19, 2007</h3>
      <h3 class="mobile-users">60% mobile</h3>
      <div class="notes">
        <p class="note">Yr (or Y-R in English, I guess) is a Norwegian weather service</p>
        <p class="note step">I's a collaboration between Norway's state broadcaster, NRK, (where I work) and the state Meteorological Institute, Met</p>
        <p class="note">NRK and Met have collaborated to deliver weather reports to Norwegians since forever, first via radio, then TV</p>
        <p class="note">In 2007, shortly after Met committed itself to making all it's data freely available to everyone, they released yr.no</p>
        <p class="note step">The service quickly became one of the most used in Norway...</p>
        <p class="note step">...and last summer had 9 million (unique) visitors per week...</p>
        <p class="note step">...of which roughly 60% was mobile traffic (evenly split between web and native apps)</p>
      </div>
    </section>

    <section id="geography">
      <img class="map" inline src="src/images/map.svg">
      <h2 class="title">web sessions (2015)</h2>
      <h3 class="no-users">578,850,000 from Norway (47%)</h3>
      <h3 class="nk-users">31 from North Korea</h3>
      <div class="notes">
        <p class="note">Now, there are only 5 million people living in Norway, so the question is "where did all this traffic come from?"</p>
        <p class="note step">According to Google, the answer would be everywhere except, apparently, Western Sahara</p>
        <p class="note step">Norway accounts for a little under 50% of traffic, with most of the remaining top 10 coming from northern Europe. </p>
        <p class="note">Strangely, we are big with South African farmers, and though we are <em>not</em> so big in Japan...</p>
        <p class="note step">...we did record 31 sessions from North Korea, so maybe that counts as big in North Korea</p>
      </div>
    </section>

    <section id="mobile">
      <div class="phone n95">
        <figure class="back ">
          <img src="src/images/n95-old.png">
          <figcaption>2007</figcaption>
        </figure>
      </div>
      <div class="phone iphone">
        <figure class="front">
          <img src="src/images/iphone-old.png">
          <figcaption>2012</figcaption>
        </figure>
        <figure class="back">
          <img src="src/images/iphone-old-www.png">
          <figcaption>2012</figcaption>
        </figure>
      </div>
      <div class="m">
        <h3>m.yr.no</h3>
        <ul>
          <li class="good">light on bandwidth</li>
          <li class="good">flexible width</li>
          <li class="bad">light on features</li>
        </ul>
      </div>
      <div class="www">
        <h3>www.yr.no</h3>
        <ul>
          <li class="good">heavy on features</li>
          <li class="bad">heavy on bandwidth</li>
          <li class="bad">fixed width</li>
        </ul>
      </div>
      <div class="notes">
        <p class="note"></p>
        <p class="note step">In 2007, if you fired-up out your top-of-the-line Nokia N95, the website would have looked something like this</p>
        <p class="note step">Unfortunately, in 2012, if you fired-up your top-of-the-line iPhone, it would still have looked something like this...</p>
        <p class="note step">...though with a little bit of work, you could opt for the desktop version instead</p>
        <p class="note step">The mobile version had a lot going for it: it was light on bandwidth, and it worked well on small screens, but it was also very light on features</p>
        <p class="note step">The desktop version, on the other hand: is heavy on features and content, but also heavy on bandwidth, and not responsive to screen size at all</p>
        <p class="note step">Although mobile represented only 1/3 of traffic at that time, it was obvious that Yr needed to do a better job for mobile web users</p>
        <p class="note">A plan was made to make the web offering more mobile friendly, starting with a mobile site optimized for the devices of the day, and eventually growing to replace the traditional "desktop" version</p>
      </div>
    </section>

    <section id="architecture">
      <div class="bg"></div>
      <div class="diagram-group">
        <div class="diagram old">
          <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
            <circle class="renderer" opacity="0.5" cx="50" cy="50" r="50"/>
            <circle class="renderer" opacity="0.7" cx="50" cy="50" r="45"/>
            <circle class="renderer" cx="50" cy="50" r="40"/>
            <circle class="api" cx="50" cy="50" r="35"/>
            <circle class="data" cx="50" cy="50" r="30"/>
            <g class="text">
              <circle fill="none" cx="50" cy="50" r="60"/>
              <line x1="98" y1="12" x2="105" y2="5" />
              <line x1="110" y1="47" x2="120" y2="47" />
              <line x1="103" y1="82" x2="110" y2="89" />
              <text opacity="0.6" x="105" y="5">DATA</text>
              <text opacity="0.6" x="120" y="52">API</text>
              <text opacity="0.6" x="110" y="100">RENDERERS</text>
            </g>
          </svg>
        </div>
        <aside class="old-aside">
          <h3>no tests!</h3>
          <h3>2 week pre-release staging!</h3>
        </aside>
      </div>
      <div class="diagram new-renderer">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <circle class="renderer" cx="50" cy="50" r="25"/>
          <g class="text">
            <circle class="ring" fill="none" cx="50" cy="50" r="35"/>
            <line x1="76" y1="72" x2="85" y2="81" />
            <text opacity="0.6" x="85" y="92">RENDERER</text>
          </g>
        </svg>
      </div>
      <div class="diagram new-api">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <circle class="api" cx="50" cy="50" r="20"/>
          <circle class="api api-2" cx="50" cy="50" r="25"/>
          <g class="text">
            <circle fill="none" cx="50" cy="50" r="35"/>
            <line x1="85" y1="50" x2="98" y2="50" />
            <text opacity="0.6" x="95" y="56">API</text>
          </g>
        </svg>
      </div>
      <div class="diagram new-data">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <circle class="data" cx="50" cy="50" r="25"/>
          <g class="text">
            <circle fill="none" cx="50" cy="50" r="35"/>
            <line x1="73" y1="24" x2="80" y2="17" />
            <text opacity="0.6" x="80" y="17">DATA</text>
          </g>
        </svg>
      </div>
      <div class="notes">
        <p class="note">In 2013, I joined the 3 person strong developer team as a front-end developer and designer</p>
        <p class="note">Much of the code base at that time dated from the last redesign in 2010</p>
        <p class="note step">And it looked something like this: picture a large blob of data wrapped in a layer of XML, with several view layers for rendering mobile pages, desktop pages, app embedded views, svgs, pdfs, and probably a lot more!</p>
        <p class="note">It's a bit unintuitive, but there was actually very little weather related stuff happening in there. Weather data comes from Met, and is mostly indexed by lat/long coordinate, so a large chunk of the application deals with matching a coordinate to a city, ski hill, your street, or any one of ten million places around the world</p>
        <p class="note">This application was reliable, and had proven itself for many years, but obviously, it was going to be difficult to update or change</p>
        <p class="note step">To make things worse, there were very few tests of any kind (it was <em>email-driven-development</em>: users would email errors and regressions they discovered), and there was a two week delay to verify releases</p>
        <p class="note step">Naturally, in our eagerness to "do it right this time", and in our fear of breaking things, we decided to start over</p>
        <p class="note step">The first job was to pull out all the place name data into it's own service. This also made it available for other projects at NRK to consume, and I think the plan is to eventually release it to the public</p>
        <p class="note step">The next step, was to build a REST API and view renderer for the new, responsive layout</p>
        <p class="note">Although this was already a big improvement, and we were now using a CI server to run tests and deploy to the cloud, our workflow for building the UI was really inefficient for such a small team: I was delivering static versions of the front-end markup to my colleague to implement in the back-end, and we ended up duplicating a lot of the work associated with generating HTML strings</p>
        <p class="note step">So after a lot of grumbling on my part, and a skunkworks prototype while our project manager was on summer holiday, we were able to split the API and view renderer into separate projects</p>
        <p class="note step">Now we each had our own monolith</p>
      </div>
    </section>

    <section id="universal">
      <div class="bg"></div>
      <div class="titles">
        <h1 class="title title-1">JavaScript <span>up</span></h1>
        <h1 class="title title-2">JavaScript <span>down</span></h1>
        <h1 class="title title-3">JavaScript <span>all the way around</span></h1>
      </div>
      <div class="notes">
        <p class="note">I'm no computer scientist, and I don't know much about <em>real</em> programming languages, but I have spent the last 18 years making things for the web, and I strongly believe in the costs associated with context switching, and the benefits of having full control over the content you create</p>
        <p class="note step">JavaScript on the server and the client is a win-win on both counts, so since late 2014, the view render stack has been back-to-front JavaScript...</p>
        <p class="note step">...or what I like to call: JavaScript Up...</p>
        <p class="note step">...JavaScript Down...</p>
        <p class="note step">...JavaScript All The Way Around</p>
      </div>
    </section>

    <section id="crap">
      <div class="bg"></div>
      <div class="diagram server">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <rect x="10" y="0" width="80" height="100" vector-effect="non-scaling-stroke" />
          <rect x="80" y="8" width="4" height="4" />
          <line x1="10" y1="20" x2="90" y2="20" vector-effect="non-scaling-stroke" />
        </svg>
      </div>
      <div class="diagram client">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <rect x="20" y="0" width="60" height="100" rx="5" ry="5" vector-effect="non-scaling-stroke" />
          <line x1="20" y1="10" x2="80" y2="10" vector-effect="non-scaling-stroke" />
          <line x1="20" y1="90" x2="80" y2="90" vector-effect="non-scaling-stroke" />
          <circle cx="50" cy="95" r="2" vector-effect="non-scaling-stroke" />
        </svg>
      </div>
      <div class="diagram document document-1">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <rect x="20" y="10" width="60" height="80" vector-effect="non-scaling-stroke" />
          <g class="loader">
            <circle cx="40" cy="40" r="2" />
            <circle cx="50" cy="40" r="2" />
            <circle cx="60" cy="40" r="2" />
          </g>
        </svg>
        <svg class="content" width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <rect x="25" y="12" width="50" height="16" vector-effect="non-scaling-stroke" />
          <rect x="25" y="32" width="50" height="16" vector-effect="non-scaling-stroke" />
          <rect x="25" y="52" width="50" height="16" vector-effect="non-scaling-stroke" />
          <rect x="25" y="72" width="50" height="16" vector-effect="non-scaling-stroke" />
        </svg>
      </div>
      <div class="diagram document document-2">
        <svg width="100px" height="100px" viewBox="0 0 100 100" xml:space="preserve">
          <rect x="20" y="10" width="60" height="80" vector-effect="non-scaling-stroke" />
          <rect x="25" y="12" width="50" height="36" vector-effect="non-scaling-stroke" />
          <rect x="25" y="52" width="50" height="16" vector-effect="non-scaling-stroke" />
          <rect x="25" y="72" width="50" height="16" vector-effect="non-scaling-stroke" />
        </svg>
      </div>
      <div class="points">
        <h3 class="point point-1">Cacheable</h3>
        <h3 class="point point-2">Resilient</h3>
        <h3 class="point point-3">Accessible</h3>
        <h3 class="point point-4">Progressive</h3>
      </div>
      <div class="notes">
        <p class="note">The easy way at this point would have been to go full-steam ahead with a Single Page App that renders most of the HTML in the browser</p>
        <p class="note step">In 2014, this was relatively common practice, but I don't think it should have ever been considered <em>best</em> practice</p>
        <p class="note step">Server-side rendering is definitely more work if you also plan on rendering things on the client, but it has major advantages:</p>
        <p class="note step">It's cacheable: server generated content can be cached close to your users. This is good for speed, good for sudden traffic spikes, and good insurance against a server meltdown</p>
        <p class="note step">It's resilient: the browser is hostile territory, almost as hostile as the network, and delivering rendered content is good insurance against client-side meltdowns</p>
        <p class="note step">It's accessible: not all devices are created equal (last year we had visits from 11,996 different ones), and server rendering makes it easier to deliver content to as many as possible</p>
        <p class="note step">And it's progressive: delivering a baseline experience to all allows us to add additional features, and improve that experience, for those devices that <em>can</em> handle it. It's also easier to not worry about those that can't</p>
        <p class="note step">Add it all up, and it's <strong>CRAP</strong>! Having to do all this is a real pain in the ass</p>
        <p class="note">Caching is nightmare; worrying about the resiliency of the network and our code is a headache; making content accessible on all those devices is impossible; and building things that can be progressively enhanced is hard</p>
        <p class="note">But let's be honest, most of us love crap: we eat crap, we watch crap, and we spend a lot of time looking at crap on our phones</p>
        <p class="note step">So, do you users a favour, and make things crappier. They'll love you for it</p>
      </div>
    </section>

    <section id="express">
      <div class="bg"></div>
      <h2 class="abstract">URL >> handler >> data >> render >> HTML</h2>
      <pre class="code app">
        <code class="js">
          const app = express();
        </code>
      </pre>
      <pre class="code middleware">
        <code class="js">
          app.use(function (req, res, next) {
            log('request from: ' + req.originalUrl);
            next();
          });
        </code>
      </pre>
      <pre class="code param">
        <code class="js">
          app.param('localeCode', function (req, res, next, localeCode) {
            if (valid(localeCode)) return next();
            return next(Error('invalid locale code'));
          });
        </code>
      </pre>
      <pre class="code route">
        <code class="js">
          const pattern = '/:localeCode({localeCode})/:page({page})';

          app.get(pattern, function (req, res, next) {
            const localeCode = req.params.localeCode;
            const query = req.query;
            //...
          });
        </code>
      </pre>
      <h2 class="lightning">[ applause ]</h2>
      <pre class="code url">
        <code class="js">
          "/en/search?q=foo"
        </code>
      </pre>
      <pre class="code anchor">
        <code class="html">
          &lt;a href="/en/search?q=foo"&gt;&lt;/a&gt;
        </code>
      </pre>
      <pre class="code handler">
        <code class="js">
          app.get('/en/search', function (req, res, next) {
            const searchQuery = req.query.q;
            //...
          });
        </code>
      </pre>
      <div class="notes">
        <p class="note">Once I decided to make things crappier with server-side rendering, I needed to find a way to smooth over the differences between server and client code</p>
        <p class="note step">The logic flow on the server starts with a URL, routes that URL to a logic handler, where you might fetch and munge some data, to finally render some HTML</p>
        <p class="note">This also seemed like a reasonable abstraction for the client</p>
        <p class="note step">So I wondered: would it be possible to initialize an application...</p>
        <p class="note step">...to add middleware...</p>
        <p class="note step">...to add request parameter validation...</p>
        <p class="note step">...and to handle a request, in the browser, just like Express.js does on the server?</p>
        <p class="note step">Well, it is possible!</p>
        <p class="note step">And not only <em>is</em> it possible, it's a great way to think about program logic:</p>
        <p class="note step">URLs are fantastic for encapsulating state...</p>
        <p class="note step">...anchor tags are great triggers for transitioning between those states...</p>
        <p class="note step">...and Express is a simple and elegant way to route state to handling logic</p>
        <p class="note step">As an added bonus, remember that good URLs help make applications <em>super</em> crappy!</p>
      </div>
    </section>

    <section id="data">
      <pre class="code shrug">
        <code class="js">
          const data = { ¯\_(ツ)_/¯ };
        </code>
      </pre>
      <pre class="code superagent">
        <code class="js">
          const request = require('superagent');

          app.get(pattern, function (req, res, next) {
            //...
            request
              .get('path/to/api')
              .end((err, response) => {
                res.data = response.body;
                //...
              });
          });
        </code>
      </pre>
      <div class="notes">
        <p class="note">As far as data is concerned, if you're familiar with Express, then you know that it has few opinions about how you manage the data you might need to render a view</p>
        <p class="note step">I don't have very strong opinions about it either, since data tends to be quite domain specific anyway, but I will say that it's easier to share data loading code between the server and client if you use a request library, like SuperAgent, that seemlessly supports both environments</p>
      </div>
    </section>

    <section id="render">
      <div class="bg"></div>
      <pre class="code render">
        <code class="js">
          res.render('search', data, (err, html) => {
            res.send(html);
          });
        </code>
      </pre>
      <pre class="code react-server">
        <code class="js">
          const pageContent = require('./pageContentComponent');

          // Server
          res.send(ReactDOMServer.renderToString(pageContent(props)));
        </code>
      </pre>
      <pre class="code react-client">
        <code class="js">
          // Client
          ReactDOM.render(pageContent(props), pageElement);
        </code>
      </pre>
      <pre class="code mixins">
        <code class="js">
          const mixins = runtime.isBrowser
            ? [require('./mixin')]
            : [];
        </code>
      </pre>
      <div class="notes">
        <p class="note">Express does have opinions about rendering, but they are, fortunately, optional and easy to ignore</p>
        <p class="note step">The client-side Express experiment would have died an early death if I had to choose between classic templating languages like Jade or Handlbars</p>
        <p class="note step">2014 was the year of the component and React.js, and although they tried to ruin things with .jsx, they <em>did</em> support server-side rendering...</p>
        <p class="note step">...and the opportunity to use the exact same component code on the server and client was too tempting to pass up</p>
        <p class="note">At the time, they also favoured extending component behaviour with optional "mixins"...</p>
        <p class="note step">...which made it easy to ignore logic for clicking, scrolling, and other interaction on the server</p>
      </div>
    </section>

    <section id="react">
      <div class="bg"></div>
      <div class="phone iphone">
        <figure class="back">
          <img class="anim" src="src/images/iphone-paint.gif">
          <img class="frame" src="src/images/iphone-frame.png">
        </figure>
      </div>
      <h3 class="title">React and the economics of dynamic web interfaces<span>Nicholas C. Zakas</span></h3>
      <div class="quotes">
        <blockquote class="quote quote-1" cite="https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces">React has, ironically, allowed us to once again think about writing web applications as a series of pages rather than a monolithic blob of JavaScript code.</blockquote>
        <blockquote class="quote quote-2" cite="https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces">[...] it's the same mental model as traditional server-only applications. A page is rendered, some changes are requested, then a page is rendered with those changes. The only difference is that this can all happen client-side.</blockquote>
      </div>
      <h2 class="coverage">80% shared code</h2>
      <div class="notes">
        <p class="note">React's killer feature for me has always been that it makes it easy to render the whole tree on each state change</p>
        <p class="note step">This makes it possible to render from the root component even when only a small part of our data has changed</p>
        <p class="note">In this example, we're rendering the full page on each keypress, and after new data arrives from our api call, but the DOM repaint (shown here in Green) is contained to the affected components</p>
        <p class="note">Although I considered this the best part of React, it wasn't until recently that I understood why</p>
        <p class="note step">At the end of January, Nicholas Zakas published a blog post called "React and the economics of dynamic web interfaces"</p>
        <p class="note">In it, he outlined his thoughts about how React has changed the performance, efficiency, and complexity costs associated with dynamic DOM updates</p>
        <p class="note step">[QUOTE]</p>
        <p class="note step">[QUOTE]</p>
        <p class="note step">If client-side Express was the lightning, this was the thunder</p>
        <p class="note step">I'm not suggesting that this is the answer to everyone's prayers, but for me, applying a server-centric model to the client is an elegant solution...</p>
        <p class="note step">...with a major practical benefit being that we now have a codebase that is 80% shared between server and client</p>
      </div>
    </section>

    <section id="caveats">
      <div class="charts">
        <img src="src/images/render-list.png">
        <img src="src/images/render-graph.png">
      </div>
      <pre class="code render">
        <code class="js">
          ReactDOMServer.renderToString(pageContent(props));
        </code>
      </pre>
      <ul class="tips">
        <li class="tip tip-1 good">
          <h3>Set production mode</h3>
          <pre class="code">
            <code class="bash">
              $ NODE_ENV=production node index.js
            </code>
          </pre>
        </li>
        <li class="tip tip-2 good">
          <h3>Use minified React</h3>
          <pre class="code">
            <code class="js">
              const React = require('react/dist/react.min');
            </code>
          </pre>
        </li>
        <li class="tip tip-3 good">
          <h3>Render components as "stateless functions"</h3>
          <pre class="code">
            <code class="js">
              const render = (props) => {
                return React.DOM.h1(props.title);
              };
            </code>
          </pre>
        </li>
      </ul>
      <h3 class="issue">Proposal: ReactDOMServer render to Stream <span>#6420</span></h3>
      <div class="notes">
        <p class="note">Now, this make for a nice story, but real life - and by real life I mean <em>production</em> - is not always so pretty</p>
        <p class="note step">It turns out that server-side React is <em>slow</em></p>
        <p class="note">These charts capture an hour's worth of render times for the main page component of the List and Graph pages: times vary roughly between 50 and 100 ms</p>
        <p class="note step">This is not great, but it's downright horrible when you consider that the call to <em>renderToString</em> is a blocking, synchronous call! That effectively means our Node process is unable to handle any other requests while rendering</p>
        <p class="note step">There are a few tricks you can employ to improve things:</p>
        <p class="note step">...be sure to run in <em>production</em> mode (generally good practice for all libraries, not just React)</p>
        <p class="note step">...use the minified version</p>
        <p class="note step">...and render all components as <em>stateless functions</em> (that is, components should not inherit from React.Component or be created via React.createClass)</p>
        <p class="note">But what React really needs is an asynchronous renderer</p>
        <p class="note step">Fortunately, work has begun on an asynchronous, streaming renderer, and although some React core team members are sceptical, it looks like React may eventually get improved server-side rendering</p>
      </div>
    </section>

    <section id="present">
      <div class="phone iphone">
        <figure class="back">
          <img class="anim" src="src/images/iphone-screencap.gif">
          <img class="frame" src="src/images/iphone-frame.png">
        </figure>
      </div>
      <div class="phone n95">
        <figure class="front ">
          <img src="src/images/n95-new.png">
        </figure>
      </div>
      <div class="notes">
        <p class="note"></p>
        <p class="note step">iPhone</p>
        <p class="note step">our old friend the Nokia N95</p>
      </div>
    </section>

    <section id="lessons">
      <div class="bg"></div>
      <div class="do">
        <h2>do</h2>
        <ul>
          <li></li>
        </ul>
      </div>
      <div class="dont">
        <h2>don't</h2>
        <ul>
          <li></li>
        </ul>
      </div>
      <div class="notes">
        <p class="note"></p>
      </div>
    </section>

    <section id="bye">
      <div class="bg"></div>
      <h1>
        Thanks!
        <a href="https://twitter.com/popeindustries">@popeindustries</a>
      </h1>
      <div class="references">
        <h3>Slides</h3>
        <a href="http://popeindustries.github.io/nodeconf-oslo-2016">http://popeindustries.github.io/nodeconf-oslo-2016</a>
        <h3>Links</h3>
        <a href="https://github.com/YR/express-client">https://github.com/YR/express-client</a>
        <a href="https://github.com/YR/component">https://github.com/YR/component</a>
        <a href="https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces">https://www.nczonline.net/blog/2016/01/react-and-the-economics-of-dynamic-web-interfaces</a>
        <a href="https://github.com/facebook/react/issues/6420">https://github.com/facebook/react/issues/6420</a>
        <a href="https://github.com/facebook/react/pull/6618">https://github.com/facebook/react/pull/6618</a>
      </div>
      <footer>
        <p>PHOTOS: Alexander Pope</p>
      </footer>
      <div class="notes">
        <p class="note">Thanks for listening, and thanks to the organisers for having me</p>
        <p class="note step">You can find the presentation slides here, along with some relevant links</p>
        <p class="note">Feel free to reach out on Twitter or GitHub if you have any questions, and if any of this sounds exciting, NRK is hiring</p>
      </div>
    </section>
  </div>
  <script src="src/lib/highlight.js"></script>
  <script src="index.js"></script>
</body>
</html>